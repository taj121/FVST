

\title{Parser}
\author{
        Th\'{e}a Johnson \\
        12307926
}
\date{\today}

\documentclass[12pt]{article}

\usepackage{syntax}
\usepackage{textcomp}
\usepackage{amsmath}

\begin{document}
\maketitle

\section{Defining the Types in OCaml}

Before the parser could be created certain types had to be defined so that it could parse the text syntax of the behaviours and the constraints to these types. These types are regions, t, sesType, stackFrame, b and con. 

These types are constructed of subtypes that represent the types that build up the main types. These subtypes are combinations of other base types. Base types all either consist of strings or have no associated type. 

In the cases where choices are offered these types consist of lists made up of tuples of the types. 

\section {Designing the Parser}

The parser in this project is written using OCamlLex (for the lexer) and Menhir (for the parser). The first stage in building this was to design an text based version of the behaviours and constraints. This involved replacing all non standard keyboard characters with ones that can be typed easily. The lexer was then written to transform this syntax into a stream of tokens. This was then parsed by the parser file and, initially, output to the console to see that it was in fact parsing correctly. 

\subsection{Technologies Used}
\subsubsection{Menhir}
Menhir is an LR(1) parser generator, meaning that it generates parsers that parse from the bottom up and have one character look ahead. Menhir is based on OCamlyacc which is in turn based on yacc. Menhir was chosen for this project since it is reputed to have more informative error messages then OCamlyacc. 

\subsubsection{OCamlLex}
OCamlLex is a lexer generator based on lex. The lexer file contains regular expressions and the semantic action that are to be performed when these expressions are encountered. 

\subsection{Text Syntax}

The syntax given in the paper can be seen in (put figure in here). The text based syntax substitutions can be seen in the table given below. 

\begin{tabular}{l c }
Mathmatical Syntax & Text Based Syntax \\
\hline
$\alpha$ & [T][A-Z a-z 1-9]+ \\
$\beta$ & [B][A-Z a-z 1-9]+ \\
$\psi$ & [S][A-Z a-z 1-9]+ \\
$\rho$ & [R][A-Z a-z 1-9]+ \\
$T x T$ & pair (T;T) \\
$ T\overset{\beta}{\rightarrow}T $ & funct T -$>$ T -[B][A-Z a-z 1-9]+ \\
$Ses^\rho$ & ses [R][A-Z a-z 1-9]+ \\
cont...

\end{tabular}

Behaviours and constraints of this syntax can then be parsed. 

\subsection{Parser}

The design phase of the parser was relatively simple. It involved encoding the syntax for the behaviours in the correct way to reflect the grammar described in the paper combined with the text based syntax that was designed for it. 

Tokens are declared for the  

\subsection{Lexer}

The lexer is written using ocamllex. This allows us to define multiple lexing rules in the same file. This has been taken advantage of to lex labels separately to the rest of the file. 

\section {Grammars}

\subsection{Types}
\begin{grammar}

<bType> ::= 'unit'
\alt ' bool '
\alt 'int'
\alt 'pair' '(' <bType> ';' <bType> ')'
\alt 'funct' <bType> '-$>$' <bType> '-' <behaviourVariable>
\alt 'ses' <region>
\alt <TVar>

\end{grammar}

\subsection{Session Types}

\begin{grammar}

<sessionType> ::= 'end'
\alt '!' <bType> <sessionType>
\alt '?' <bType> <sessionType>
\alt '!' <sessionType> <sessionType>
\alt '?' <sessionType> <sessionType>
\alt '(+)' [<sesOpL>] '('<lable> ';' <sessionType>')'
\alt '+' [<sesOpL>] [<sesOpL>]
\alt <SVar>

<sesOpL> ::= seperated_list(',',<ses_opt_field>)

<ses_opt_field> := (<lable> ';' <sessionType>)

\end{grammar}

\subsection{Behaviour}

\begin{grammar}
<behaviour> ::= <behaviourVariable>
\alt 'tau'
\alt <behaviour> ';' <behaviour>
\alt 'chc' (<behaviour>,<behaviour>)
\alt 'rec' <behaviourVariable> (<behaviour>)
\alt 'spn' (<behaviour>)
\alt 'psh' (<lable>,<sessionType>)
\alt <region> '!' <behaviourVariable>
\alt <region> '?' <behaviourVariable>
\alt <region> '!' <region>
\alt <region> '?' <lable>
\alt <region> '!' <lable>
\alt <region> '?' option[<oplist>]

<oplist> ::= seperated_list(',',opt_feild)

<opt_feild> ::= (<lable> ';' <behavioiur>)

\end{grammar}

\subsection {Region Variables}

\begin{grammar}

<regionVar> ::= <lable>
\alt <region>

\end{grammar}

\subsection{Constraints}

\begin{grammar}

<constr> ::= <bType> \textless <bType>
\alt <behaviour> \textless <behaviour>
\alt <region> \texttildelow <regionVar>
\alt <channel> \texttildelow <sessionType>
\alt <channelEnd> \texttildelow <sessionType>
\alt <contr> ',' <constr>
\alt $\epsilon$

\end{grammar}
% \begin{grammar}

% parse_behaviour ::= <behaviour> <constraint>

% \end{grammar}

\end{document}