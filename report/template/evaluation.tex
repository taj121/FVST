%!TEX root = FVST.tex
\chapter{Evaluation} \label{chaptest}

This chapter explains how the application was evaluated as well as giving a reflection on the results of the evaluation.

\section{Testing}

Testing was conducted in stages. Firstly the parser and lexer were tested, then the constraint storage and finally the behaviour checker.

\subsection{Lexer and parser}

The testing for the lexer and parser was relatively simple. To string methods were written for each of the data types and the resulting behaviours and constraints from the parsing were printed out to the console. 

Initially they were printed in the exact form that they were input. This allowed a side by side comparison of the input and output which allowed for errors to be spotted quickly and easily. 

\subsection{Constraint storage}

Testing for the constraint storage was done in a similar way to that of the lexer and parser. Instead of printing the constraints as they were read in the function was updated to print them as they were been stored. This allowed for them to be quickly checked against the input to see if they were been stored correctly. 

For example in the case of region constraints the input could contain constraints such as: 

\begin{lstlisting}
R12 ~ $l1$, 
R11 ~ R12,
R15 ~ $l3$
\end{lstlisting}

Which should then be output in the form: 

\begin{lstlisting}
label: l1
regions: R11, R12
label: l2
regions: R15
\end{lstlisting}

It is then easy to check if the regions listed under a particular label are in fact linked to it. 

\subsection{Behaviour checker}

The testing for the behaviour checker was the most in depth. A test suit has been developed that includes the examples given in \ref{examplesChapt}. As well as these several small programs were written to test the individual rules one at a time. 

These small programs were first written to test each of the rules with the basic situations under which they should pass or fail. The scenarios for passing involve setting up a situation where a simple form of the correct stack frame and behaviour are examined. It is also ensured that the relevant constraints are met. 

The test to ensure that the checker fails correctly involve setting up situations where each of the constraints for a rule is broken in turn. Ideally only one constraint is broken per test but in some cases it is more practical to test breaking multiple constraints at once. 

Writing the test in this way has also shown that the constraint checks work as expected.

\section{Reflection}

The test detailed in the previous section have shown that all components of the program behave as is expected. While it is possible that more extensive test might find some unexpected behaviour it seems unlikely. 

The development of the project in a functional style meant that once the files compiled correctly the behaviour of the program was almost always what was specified. In the main the problems discovered by the tests were my own misunderstandings of the rules or the constraints. The tests these misunderstandings more obvious and so easier to fix. 

The test was also invaluable in showing where the error hints from the behaviour checker should display. For example the tests for the ICh rule showed an uncaught Not_found exception instead of displaying an error message. This allowed me to go back to the program, catch the exception and output a more helpful message. 

